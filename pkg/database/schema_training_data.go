package database

import (
	"encoding/json"
	"reflect"
	"time"
)

type TrainingDataSchema struct {
	/*
		Id is the primary key for the training data
	*/
	Id string `gorm:"column:id;primaryKey" json:"id"`
	/*
		The embedding Id represents the unique identifier for the embedding

			- an embedding is associated with a training data Id, allowing for multiple embeddings to be associated with a single training data

				- ex: when chunking large documents, each chunk will have a different embedding Id, but the same training data Id

	*/
	EmbeddingId string `gorm:"column:embedding_id" json:"embedding_id"`
	/*
	 The Embedding is a 2 dimensional array of float64 values representing the embedding of the training data

	 - embedded values are typically generated by a model, such as BERT, and are used to represent the training data in a lower dimensional space
	*/
	Embedding [][]float64 `gorm:"column:embedding;type:bytes" json:"embedding"`
	/*
		 The EmbeddingModel is the name of the model used to generate the embedding

		 	- ex: BERT, GPT-3, etc. Each model will have a different embedding size and structure, so the model name is important for interpreting the embedding

		blah blah blah
	*/

	EmbeddingModel string `gorm:"column:embedding_model" json:"embedding_model"`
	/*
		Source is the origin of the training data

		- the source is tightly bound to the extension which created the training data

		- ex: a web scraper extension will have a source of "web-scraper"

		- additional note: the source can also indicate the type of data being scraped

	*/
	Source string `gorm:"column:source" json:"source"`
	/*
		SourceURL is the URL of the source of the training data

		  - ex: the URL of the webpage scraped by a web scraper
				- if there is no URL, this field will be empty
	*/
	SourceURL string `gorm:"column:source_url" json:"source_url"`
	/*
		ChunksTotal is the total number of chunks created from the training data
	*/
	ChunksTotal int `gorm:"column:chunks_total" json:"chunks_total"`
	/*
		ChunksIndexed is the total number of chunks that have been indexed
	*/
	ChunksIndexed int `gorm:"column:chunks_indexed" json:"chunks_indexed"`
	/*
		Content is the text content of the training data
	*/
	Content string `gorm:"column:content" json:"content"`
	/*
		CreatedAt is the time the training data was created
	*/
	CreatedAt time.Time `gorm:"column:created_at" json:"created_at"`
	/*
		UpdatedAt is the time the training data was last updated
	*/
	IndexedAt time.Time `gorm:"column:indexed_at" json:"indexed_at"`
	/*
		IsActive is a boolean flag indicating if the training data is active
	*/
	IsActive bool `gorm:"column:is_active" json:"is_active"`
	/*
		Category is the category of the training data
	*/
	Category string `gorm:"column:category" json:"category"`
	/*
		Metadata contains additional information about the training data
	*/
	Metadata string `gorm:"column:metadata" json:"metadata"`
}

func (t TrainingDataSchema) TableName() string {
	return "training_data"
}

func (t TrainingDataSchema) Schema() map[string]string {
	var m = make(map[string]string)
	v := reflect.ValueOf(t)
	for i := 0; i < v.NumField(); i++ {
		field := v.Type().Field(i)
		if field.Type.String() == "[]float64" {
			m[field.Name] = "blob"
		}
		if field.Type.String() == "string" {
			m[field.Name] = "text"
		}
		if field.Type.String() == "int" {
			m[field.Name] = "integer"
		}
		if field.Type.String() == "bool" {
			m[field.Name] = "integer"
		}
		if field.Type.String() == "time.Time" {
			m[field.Name] = "date"
		}
	}
	return m
}

func (t TrainingDataSchema) Columns() []string {
	var c []string
	v := reflect.ValueOf(t)
	for i := 0; i < v.NumField(); i++ {
		c = append(c, v.Type().Field(i).Name)
	}
	return c
}

func (t TrainingDataSchema) GetId() string {
	return t.Id
}

func (t TrainingDataSchema) String() string {
	jsonBytes, err := json.Marshal(t)
	if err != nil {
		return ""
	}

	return string(jsonBytes)
}
